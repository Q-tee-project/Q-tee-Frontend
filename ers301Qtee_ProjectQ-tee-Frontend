[1mdiff --git a/src/components/LaTeXRenderer.tsx b/src/components/LaTeXRenderer.tsx[m
[1mindex e886d7d..b96caa9 100644[m
[1m--- a/src/components/LaTeXRenderer.tsx[m
[1m+++ b/src/components/LaTeXRenderer.tsx[m
[36m@@ -17,13 +17,10 @@[m [mexport const LaTeXRenderer: React.FC<LaTeXRendererProps> = ({[m
     if (!text) return '';[m
 [m
     try {[m
[31m-      // 1단계: 기본 정리[m
[32m+[m[32m      // 1단계: 기본 패턴 정리 (잘못된 분수 표기 등)[m
       let processedText = cleanBasicPatterns(text);[m
 [m
[31m-      // 2단계: 줄바꿈 처리[m
[31m-      processedText = handleLineBreaks(processedText);[m
[31m-[m
[31m-      // 3단계: 수식과 일반 텍스트 분리 처리[m
[32m+[m[32m      // 2단계: 수식과 일반 텍스트 분리 및 렌더링[m
       processedText = renderMixedContent(processedText);[m
 [m
       return processedText;[m
[36m@@ -49,57 +46,47 @@[m [mexport const LaTeXRenderer: React.FC<LaTeXRendererProps> = ({[m
     // 빈 LaTeX 수식 제거 ($$)[m
     text = text.replace(/\$\s*\$/g, '');[m
 [m
[31m-    return text;[m
[31m-  };[m
[31m-[m
[31m-  const handleLineBreaks = (text: string): string => {[m
[31m-    // 줄바꿈 패턴들을 <br />로 변환[m
[31m-    text = text.replace(/\\n/g, '<br />');[m
[31m-    text = text.replace(/\n/g, '<br />');[m
[32m+[m[32m    // 분수 패턴 전처리 개선[m
[32m+[m[32m    // \frac{a},{b} 또는 \frac a,b 또는 \frac{a},b 패턴을 \frac{a}{b}로 변환[m
[32m+[m[32m    text = text.replace(/\\frac\s*\{?([^}]*?)\s*\}?\s*,\s*\{?([^}]*?)\}/g, '\\frac{$1}{$2}');[m
 [m
[31m-    // 잘못된 br 태그 수정 (< < 같은 경우)[m
[31m-    text = text.replace(/\s*<\s*<\s*/g, '<br />');[m
[31m-    text = text.replace(/\s*<\s*br\s*\/?\s*>\s*/gi, '<br />');[m
[32m+[m[32m    // 이중 백슬래시 + 쉼표 분수 패턴도 처리[m
[32m+[m[32m    text = text.replace(/\\\\frac\s*\{?([^}]*?)\s*\}?\s*,\s*\{?([^}]*?)\}/g, '\\frac{$1}{$2}');[m
 [m
     return text;[m
   };[m
 [m
   const renderMixedContent = (text: string): string => {[m
[31m-    // 텍스트를 $ 기호를 기준으로 분할[m
[31m-    const parts = text.split(/(\$[^$]*\$|\$\$[^$]*\$\$)/);[m
[32m+[m[32m    // 텍스트를 $ 기호와 \frac{} 패턴을 기준으로 분할[m
[32m+[m[32m    const parts = text.split(/(\$[^$]*\$|\$\$[^$]*\$\$|\\frac\{[^}]*\}\{[^}]*\})/g);[m
 [m
     return parts[m
       .map((part) => {[m
[32m+[m[32m        if (!part) return '';[m
         // $ 기호로 감싸진 부분은 LaTeX로 렌더링[m
         if (part.startsWith('$') && part.endsWith('$')) {[m
           return renderSingleMathExpression(part);[m
[32m+[m[32m        }[m
[32m+[m[32m        // \frac{} 패턴이 포함된 부분은 LaTeX로 렌더링[m
[32m+[m[32m        else if (part.startsWith('\\frac{') && part.endsWith('}')) {[m
[32m+[m[32m          return renderSingleMathExpression('$' + part + '$');[m
         } else {[m
[31m-          // 일반 텍스트 처리 - 혼합 컨텐츠 고려[m
[31m-          return processTextContent(part);[m
[32m+[m[32m          // 일반 텍스트 처리 (줄바꿈 변환 및 불필요한 $ 제거)[m
[32m+[m[32m          return cleanTextContent(part);[m
         }[m
       })[m
       .join('');[m
   };[m
 [m
[31m-  const processTextContent = (text: string): string => {[m
[31m-    // 잘못된 $ 기호 제거[m
[31m-    text = cleanTextContent(text);[m
[31m-[m
[31m-    // 혼합 컨텐츠 처리: 변수+한글 (x축, y절편 등)[m
[31m-    // 이미 백엔드에서 $x$축 형태로 처리되어 올 수 있지만, 혹시 놓친 경우를 위해[m
[31m-    text = text.replace(/\b([a-zA-Z])([가-힣]+)/g, (match, variable, korean) => {[m
[31m-      // 단일 변수 + 한글인 경우, 변수만 LaTeX로 렌더링[m
[31m-      try {[m
[31m-        const renderedVar = katex.renderToString(variable, {[m
[31m-          displayMode: false,[m
[31m-          throwOnError: false,[m
[31m-          strict: false,[m
[31m-        });[m
[31m-        return renderedVar + korean;[m
[31m-      } catch (error) {[m
[31m-        return match; // 실패 시 원본 반환[m
[31m-      }[m
[31m-    });[m
[32m+[m[32m  const cleanTextContent = (text: string): string => {[m
[32m+[m[32m    // 일반 텍스트에서 잘못된 $ 기호만 제거[m
[32m+[m[32m    // 단독 $ 기호 제거[m
[32m+[m[32m    text = text.replace(/(?<!\$)\$(?!\$)(?![a-zA-Z\\])/g, '');[m
[32m+[m
[32m+[m[32m    // AI가 생성한 '\\n'과 일반 '\n'을 모두 <br />로 변환[m
[32m+[m[32m    // 이 로직이 일반 텍스트에만 적용됩니다.[m
[32m+[m[32m    text = text.replace(/\\n/g, '<br />'); // AI가 생성한 literal '\n' 처리[m
[32m+[m[32m    text = text.replace(/\n/g, '<br />'); // 일반 개행 문자 처리[m
 [m
     return text;[m
   };[m
[36m@@ -109,28 +96,12 @@[m [mexport const LaTeXRenderer: React.FC<LaTeXRendererProps> = ({[m
     let math = isDisplayMode ? mathString.slice(2, -2) : mathString.slice(1, -1);[m
 [m
     // 빈 수식이나 순수 숫자/텍스트는 LaTeX 렌더링하지 않음[m
[31m-    if ([m
[31m-      !math.trim() ||[m
[31m-      /^\d+$/.test(math.trim()) ||[m
[31m-      /^\d+,\d+/.test(math.trim()) ||[m
[31m-      /^[가-힣\s,]+$/.test(math.trim())  // 순수 한글만 있는 경우 제외 (변수 포함된 것은 렌더링)[m
[31m-    ) {[m
[32m+[m[32m    if (!math.trim() || /^[가-힣\s,]+$/.test(math.trim())) {[m
       return math.trim();[m
     }[m
 [m
[31m-    // 백엔드에서 처리되지 못한 추가 패턴들 정리[m
[31m-    // 1. 함수 표현에서 공백 정리: P( x+y , y-x ) -> P(x+y, y-x)[m
[31m-    math = math.replace(/\(\s+/g, '(').replace(/\s+\)/g, ')').replace(/\s*,\s*/g, ', ');[m
[31m-[m
[31m-    // 2. 분수에서 불필요한 공백 제거: \frac{ a+b }{ 2 } -> \frac{a+b}{2}[m
[31m-    math = math.replace(/\\frac\{\s*/g, '\\frac{').replace(/\s*\}\{\s*/g, '}{').replace(/\s*\}/g, '}');[m
[31m-[m
[31m-    // 3. 지수 표현 정리[m
[31m-    math = math.replace(/(\w+\^\{[^}]+\})\s+(\w+\^\{[^}]+\})/g, '$1 \\cdot $2');[m
[31m-    math = math.replace(/(\w+)\^\{(\w+)\}\s+(\w+)\^\{(\w+)\}/g, '$1^{$2} \\cdot $3^{$4}');[m
[31m-[m
[31m-    // 4. 연산자 주변 공백 정리[m
[31m-    math = math.replace(/\s*([+\-*/=])\s*/g, ' $1 ').replace(/\s+/g, ' ').trim();[m
[32m+[m[32m    // 불필요한 공백 제거[m
[32m+[m[32m    math = math.replace(/\s*([+\-*/=])\s*/g, ' $1 ').trim();[m
 [m
     try {[m
       const rendered = katex.renderToString(math, {[m
[36m@@ -141,25 +112,11 @@[m [mexport const LaTeXRenderer: React.FC<LaTeXRendererProps> = ({[m
       return rendered;[m
     } catch (error) {[m
       console.warn('LaTeX rendering error:', error, 'for math:', math);[m
[31m-      return math; // 수식 부분만 반환 ($ 기호 제거)[m
[32m+[m[32m      return math;[m
     }[m
   };[m
 [m
[31m-  const cleanTextContent = (text: string): string => {[m
[31m-    // 일반 텍스트에서 잘못된 $ 기호 제거[m
[31m-    // $16,28,40 같은 패턴[m
[31m-    text = text.replace(/\$(\d+(?:,\d+)*)/g, '$1');[m
[31m-[m
[31m-    // 단독 $ 기호 제거[m
[31m-    text = text.replace(/(?<!\$)\$(?!\$)(?![a-zA-Z\\])/g, '');[m
[31m-[m
[31m-    // 남은 LaTeX 명령어들 (백엔드에서 놓친 것들) 제거[m
[31m-    text = text.replace(/\\[a-zA-Z]+/g, '');[m
[31m-[m
[31m-    return text;[m
[31m-  };[m
[31m-[m
   const processedContent = renderLaTeX(content);[m
 [m
   return <div className={className} dangerouslySetInnerHTML={{ __html: processedContent }} />;[m
[31m-};[m
[32m+[m[32m};[m
\ No newline at end of file[m
